\documentclass[journal]{vgtc}                % final (journal style)
%\documentclass[review,journal]{vgtc}         % review (journal style)
%\documentclass[widereview]{vgtc}             % wide-spaced review
%\documentclass[preprint,journal]{vgtc}       % preprint (journal style)
%\documentclass[electronic,journal]{vgtc}     % electronic version, journal

%% Uncomment one of the lines above depending on where your paper is
%% in the conference process. ``review'' and ``widereview'' are for review
%% submission, ``preprint'' is for pre-publication, and the final version
%% doesn't use a specific qualifier. Further, ``electronic'' includes
%% hyperreferences for more convenient online viewing.

%% Please use one of the ``review'' options in combination with the
%% assigned online id (see below) ONLY if your paper uses a double blind
%% review process. Some conferences, like IEEE Vis and InfoVis, have NOT
%% in the past.

%% Please note that the use of figures other than the optional teaser is not permitted on the first page
%% of the journal version.  Figures should begin on the second page and be
%% in CMYK or Grey scale format, otherwise, colour shifting may occur
%% during the printing process.  Papers submitted with figures other than the optional teaser on the
%% first page will be refused.

%% These three lines bring in essential packages: ``mathptmx'' for Type 1
%% typefaces, ``graphicx'' for inclusion of EPS figures. and ``times''
%% for proper handling of the times font family.

\usepackage{mathptmx}
\usepackage{graphicx}
\usepackage{times}
\usepackage{amsmath}
\usepackage{stmaryrd}%\rightarrowtriangle
\usepackage{graphicx}
\usepackage{enumerate}
\usepackage{natbib}
\usepackage{url}
% for gifs -- http://tex.stackexchange.com/questions/7602/how-to-add-a-gif-file-to-my-latex-file
\usepackage{movie15}

%% We encourage the use of mathptmx for consistent usage of times font
%% throughout the proceedings. However, if you encounter conflicts
%% with other math-related packages, you may want to disable it.

%% This turns references into clickable hyperlinks.
\usepackage[bookmarks,backref=true,linkcolor=black]{hyperref} %,colorlinks
\hypersetup{
  pdfauthor = {},
  pdftitle = {},
  pdfsubject = {},
  pdfkeywords = {},
  colorlinks=true,
  linkcolor= black,
  citecolor= black,
  pageanchor=true,
  urlcolor = black,
  plainpages = false,
  linktocpage
}

% Reduce space between enumerations
\newenvironment{tight_enumerate}{
\begin{enumerate}
  \setlength{\itemsep}{0pt}
  \setlength{\parskip}{0pt}
}{\end{enumerate}}

%% If you are submitting a paper to a conference for review with a double
%% blind reviewing process, please replace the value ``0'' below with your
%% OnlineID. Otherwise, you may safely leave it at ``0''.
\onlineid{0}

%% declare the category of your paper, only shown in review mode
\vgtccategory{Research}

%% allow for this line if you want the electronic option to work properly
\vgtcinsertpkg

%% In preprint mode you may define your own headline.
%\preprinttext{To appear in IEEE Transactions on Visualization and Computer Graphics.}

%% Paper title.
\title{Extending ggplot2's grammar of graphics implementation for linked and dynamic graphics on the web}

%% This is how authors are specified in the journal style

%% indicate IEEE Member or Student Member in form indicated below
\author{Carson Sievert, Toby Dylan Hocking, Susan VanderPlas, Jun Cai, Kevin Ferris}
\authorfooter{
\item
 Carson Sievert is with the Department of Statistics at Iowa State University. E-mail: sievert@iastate.edu
\item
 Toby Dylan Hocking is with the McGill University department of Human Genetics. E-mail: toby.hocking@mail.mcgill.ca
\item
 Susan VanderPlas is with the Department of Statistics at Iowa State University. E-mail: srvanderplas@gmail.com
\item
  Jun Cai is with the Center for Earth System Science at Tsinghua University. E-mail: cai-j12@mails.tsinghua.edu.cn
\item
  Kevin Ferris is with the Baseball Operations Department of the Tampa Bay Rays. E-mail: kevin.ferris10@gmail.com
}

%other entries to be set up for journal
\shortauthortitle{Biv \MakeLowercase{\textit{et al.}}: Global Illumination for Fun and Profit}
%\shortauthortitle{Firstauthor \MakeLowercase{\textit{et al.}}: Paper Title}

%% Abstract section.
\abstract{ 
  The web is the most popular medium for sharing interactive
  data visualizations thanks to the portability of the web browser and
  the accessibility of the internet. Unfortunately, creating
  interactive web graphics often requires a working knowledge of
  numerous web technologies that are foreign to many people working
  with data. As a result, web graphics are rarely used for exploratory
  data analysis where quick iteration between different visualizations
  is of utmost importance. This is the core strength of ggplot2, a
  popular data visualization package for the world's leading
  open-source statistical programming language, R. The conceptual
  framework behind ggplot2 is based on the grammar of graphics, which
  lays a foundation for describing any static graphic as a small set
  of independent components. Perhaps the most fundamental component is
  the mapping from abstract data to the visual space, sometimes
  referred to as the aesthetic mapping. We propose adding two new
  aesthetics to the grammar, which together are sufficient for
  elegantly describing both animations and certain classes of
  coordinated linked views. We implement this extension in the
  open-source R package animint, which converts ggplot2 objects to
  interactive web visualizations via D3.  
} % end of abstract

%% Keywords that describe your work. Will show as 'Index Terms' in journal
%% please capitalize first letter and insert punctuation after last keyword
\keywords{Interactive graphics, Statistical graphics, Exploratory data analysis, Web technologies}

%% Uncomment below to include a teaser figure.
%    \teaser{
%    \centering
%    \includegraphics[width=16cm]{CypressView}
%    \caption{In the Clouds: Vancouver from Cypress Mountain.}
%   }

%% Uncomment below to disable the manuscript note
%\renewcommand{\manuscriptnotetxt}{}

%% Copyright space is enabled by default as required by guidelines.
%% It is disabled by the 'review' option or via the following command:
% \nocopyrightspace

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%% START OF THE PAPER %%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

%% The ``\maketitle'' command must be the first command after the
%% ``\begin{document}'' command. It prepares and prints the title block.

%% the only exception to this rule is the \firstsection command
\firstsection{Introduction}

\maketitle

%% In general, there are three influential roles involving an Animint
%% visualization: the developer, who implements the Animint library; the
%% designer, who uses the Animint library to define a visualization; and
%% the user, who selects data subsets to view in a web browser. The main
%% goal of Animint is to provide an expressive language for designers,
%% while allowing users the freedom to interact with the plot to
%% selectively view data subsets of interest. The designer specifies data
%% sets and maps variables to interactive visual elements using the
%% Animint DSL, then uses the Animint library to compile and save an
%% interactive animation. The user writes no code, but can view and
%% interact with an Animint visualization by clicking Scalable Vector
%% Graphics (SVG) elements in a web browser. The Animint library
%% developer is responsible for the plot rendering details, which allows
%% the others to focus on designing and consuming visualizations.

<<opts, echo=FALSE, message=FALSE, cache=FALSE>>=
knitr::opts_chunk$set(tidy = FALSE, eval = FALSE)
knitr::opts_knit$set(out.format = "latex")
knitr::knit_theme$set("edit-matlab")
@

%%Interactive and dynamic statistical graphics toolkits play an important role in the exploratory phase of a data analysis cycle. The web is an attractive platform for interactive graphics thanks to its portability and accessibility, but due to a lack of tools for quick iteration, web graphics are not a practical tool for exploring data. Instead, they are mostly used for the presentation of findings (i.e., when the 'correct' visualization is already known). This is a source of conflict, as one often needs different tools depending on whether the work is exploratory or intended for public consumption, which results in wasted effort.

%%The R package \texttt{ggplot2} is a popular tool for data visualization due in part to its elegant design inspired by the grammar of graphics. The fundamental concept in the grammar of graphics is that any graphic can be described through a set of mappings from data variables to visual space, referred to commonly as \texttt{aesthetic} mappings. The grammar of graphics and ggplot2 were designed for static graphics


The world's leading open source statistical programming language, R, has a rich history of interfacing with computational tools for the use of people doing data analysis and statistics research \citep{RCore}. Understanding R's core audience is important, as they typically want to maximize their time working on data analysis problems, and minimize time spent learning computational tools. R excels in this regard, as it is designed specifically for interactive use, where users can quickly explore their data using highly expressive interfaces. Another key player in R's success story is its packaging infrastructure, which provides tools for distributing entire research conpendium(s) (code, data, documentation, auxiliary documents, etc) \citep{Gentleman:Lang}. 

One of the most widely used R packages is ggplot2 \citep{ggplot2-book}, a data visualization package inspired by the grammar of graphics \citep{wilkinson}. In fact, \citet{Donoho:2015tu} writes: ``This effort may have more impact on todayâ€™s practice of data analysis than many highly-regarded theoretical statistics papers".
In our experience, ggplot2 has made an impact thanks to its foundation in the grammar of graphics, carefully chosen defaults, and overall usability. This helps data analysts rapidly iterate and discover informative visualizations -- an essential task in exploratory data analysis (EDA). When dealing with high-dimensional data, however, it is often useful to produce interactive and/or dynamic graphics, which ggplot2 does not inherently support. 

%%Since the design space of interactive and dynamic graphics is so large, however, it is extremely difficult to design an fully featured interface that is useful in a EDA setting.

Interactive graphics toolkits in R have been used for decades to enhance the EDA workflow, but these approaches are often not easy to reproduce or distribute to a larger audience. It is true that most graphics generated during EDA are ultimately not useful, but sometimes, understanding gained during this phase is most easily shared via the interactive graphics themselves. Thus, there is value is being able to easily share, and embed interactive graphics inside a larger report. Unfortunately, this is typically hard, if not impossible, using traditional interactive graphics toolkits. As a result, there is a large disconnect between the visualization tools that we use for exploration versus presentation. 

We aim to narrow this gap in visualization tools by extending ggplot2's grammar of graphics implementation for interactive and dynamic web graphics. By adding two new aesthetics to the grammar, \texttt{clickSelects} and \texttt{showSelected}, we are able to express animated transitions and perform database queries via direct manipulation of linked views like those described in \citep{Ahlberg:1991} and \citep{Buja:1991vh}. Other aesthetics, such as \texttt{tooltip} and \texttt{href}, can be used to identify data values and link to web pages. The rest of the paper will proceed as follows: Section~3 discusses the \texttt{clickSelects} and \texttt{showSelected} aesthetics in detail, Section~4 discusses our current implementation in the R package animint, Section~5 compares our implementation to similar work, Section~6 provides a handful of examples, ...


\section{Related Work}

We aim to provide a system which empowers ggplot2 users to go beyond the confines of static graphics with minimal friction imposed upon their current workflow. We acknowledge that numerous systems which support similar visualization techniques exist outside of the R ecosystem, but we intentionally focus on R interfaces since the surrounding statistical computing environment is crucial for maintaining a practical exploratory data analysis workflow.

It is important to acknowledge that ggplot2 is built on top of the R package grid, a low-level graphics system, which is now bundled with R itself \citep{RCore}. Neither grid, nor base R graphics, have strong support for handling user interaction creating a need for add-on packages. There are a number of approaches these packages take to render graphics, each with their own benefits and drawbacks. These packages traditionally build on low-level R interfaces to graphical systems such as GTK+ \citep{RGtk2}, Qt \citep{qtbase, qtpaint}, or Java GUI frameworks \citep{rJava}. In general, the resulting system can be very fast and flexible, but sharing and reproducing output is difficult due to the heavy software requirements. Although there may be sacrifice in performance, using the modern web browser as a canvas is more portable, accessible, and composable (graphics can be embedded within larger frameworks/documents).

Base R does provide a Scalable Vector Graphics (SVG) device, \texttt{svg()}, via the Cairo graphics API \citep{cairo}. The R package SVGAnnotation \citep{SVGAnnotation} provides functionality to post-process \texttt{svg()} output in order to add interactive and dynamic features. This is a powerful approach, since in theory it can work with any R graphic, but the package is self described as a proof-of-concept which reverse engineers poorly structured \texttt{svg()} output. As a result, anyone wishing to extend or alter the core functionality needs a deep understanding of base graphics and SVG. 

The lack of well-structured SVG for R graphics motivated the gridSVG package which provides sensible structuring of SVG output for grid graphics \citep{gridSVG}. This package also provides some low-level tools for animating or adding interactive features, where grid objects must be referenced by name. As a result, if one wanted to use this interface to add interactivity to a ggplot2 plot, they must know and understand the naming scheme ggplot2 uses internally and hope it does not change down the road. An interface where interactivity can be expressed by referencing the data to be visualized, rather than the building blocks of the graphics system, would be preferable since the former interface is decoupled from the implementation and does not require knowledge of grid.
%% TODO: maybe draw a comparison to D3js vs DC? ^^^

In terms of the user interface, the R package gganimate is very similar to our system \citep{gganimate}. It directly extends ggplot2 by adding a new aesthetic, named \texttt{frame}, which splits the data into subsets (one for each unique value of the frame variable), produces a static plot for each subset, and uses the animation package to combine the images into a key frame animation \citep{animation}. This is quite similar, but not as flexible as our system's support for animation, which we fully describe in Section~\ref{sec:animation}. Either system has the ability to control the amount of time that a given frame is displayed, but our system can also animate the transition between frames via the \texttt{d3.transition()} API \citep{d3}. Smooth transitions help us track positions between frames, which is useful in many scenarios, such as the touring example discussed in Section~6.

Tours are a useful visualization technique for exploring high-dimensional data which requires interactive and dynamic graphics. The open source software ggobi is currently the most fully-featured tool for touring data, but also provides the ability to produce more standard statistical graphics, and general interactive techniques such as linking, zooming, panning, and identifying \citep{ggobi:2007}. The R package rggobi \citep{rggobi} provides an R interface to ggobi's graphical interface, but unfortunately, the software requirements for installation and use of this toolchain are heavy and stringent. Furthermore, sharing the interactive versions of these graphics are not possible. The R package cranvas aims to be the successor to ggobi, with support for similar interactive techniques, but with a more flexible interface for describing plots inspired by the grammar of graphics \citep{cranvas}. Cranvas also has heavy and stringent software requirements which limits the portability and accessibility of the software.

Another R package for interactive graphics which draws design inspiration from the grammar of graphics is ggvis \citep{ggvis}. It does not directly extend ggplot2, but instead provides a brand new purely functional interface which is designed with interactive graphics in mind. It currently relies on Vega to render the SVG graphics from JSON \citep{vega}, and the R package shiny to enable many of its interactive capabilities \citep{shiny}. The interface gives tremendous power to R users, as it allows one to write R functions to handle user events. This power does come with a cost, though, as sharing and hosting ggvis graphics may require special web server software, even when the interaction logic could be handled entirely client-side. As we outline in Section~4, our system does not require a web server, but can be used inside shiny web applications, when desired.

\section{Extending the layered grammar of graphics}

In this section, we propose an extension to the layered grammar of graphics \citep{ggplot2-paper} which enables declarative expression of animations and database queries via direct manipulation. In the ggplot2 system, there are five essential components that define a layer of graphical markings: data, mappings (i.e., aesthetics), geometry, statistic, and position. These simple components are easily understood in isolation and can be combined in many ways to express a wide array of graphics. For a simple example, here is one way to create a scatterplot in ggplot2 of variables named \texttt{<X>} and \texttt{<Y>} in \texttt{<DATA>}:

<<gg>>=
ggplot() + layer(
  data = <DATA>, 
  mapping = aes(x = <X>, y = <Y>), 
  geom = "point", 
  stat = "identity",
  position = "identity"
)
@

For every geometry, ggplot2 provides a convenient wrapper around \texttt{layer()} which provides sensible defaults for the statistic and position (in this case, both are "identity"):

<<gg2>>=
ggplot() + geom_point(
  data = <DATA>, 
  aes(x = <X>, y = <Y>)
)
@

A single ggplot2 plot can be comprised of multiple layers, and different layers can correspond to different data. Since each graphical mark within a ggplot2 layer corresponds to one (or more) observations in \texttt{<DATA>}, aesthetic mappings provide a mechanism for mapping graphical selections to the original data (and vice-versa) which is essential to any interactive graphics system \citep{viewing-pipeline, plumbing}. Thus, given a way to combine multiple ggplot2 plots into a single view, this design can be extended to support a notion of multiple linked views, as those discussed in \citep{Ahlberg:1991} and \citep{Buja:1991vh}.

\subsection{Direct Manipulation of Database Queries}

\citet{ggobi:2007} use SQL queries to formalize the direct manipulation methods discussed in \citet{Ahlberg:1991} and \citet{Buja:1991vh}. As it turns out, we can embed this framework inside the layered grammar of graphics with two classes of new aesthetics: one class to define a selection source and one to define a target. This is most easily seen using our animint implementation, which has a \texttt{clickSelects} aesthetic for defining the selection source (and modifying the selection via mouse click) and a \texttt{showSelected} aesthetic for defining the target. Here we use animint to create a linked view between a bar chart and a scatter plot, where the user can click on bars to control the points shown in the scatterplot, as shown in the video in Figure~\ref{fig:tips}. As a result, we can quickly see how the relationship among tip amount and total bill amount depends on whether the customer is smoker.

<<gg3>>=
library(animint)
p1 <- ggplot() + geom_bar(
  data = reshape2::tips, 
  aes(x = smoker, clickSelects = smoker),
)
p2 <- ggplot() + geom_point(
  data = reshape2::tips, 
  aes(x = total_bill, y = tip, 
      showSelected = smoker)
)
animint2dir(list(p1 = p1, p2 = p2))
@

\begin{figure}[htp]
	\centerline{\includemovie[poster={tips.png}, text={}]{250pt}{120pt}{tips.mov}}
	\label{fig:tips}
	\caption{Video demonstrating linked database querying via direct manipulation using animint. You can view this movie by opening the pdf document with Adobe Reader and clicking on the figure above, or view it online at \url{https://vimeo.com/160496419}}
\end{figure}

In essense, the R code above allows us to use direct manipulation to dynamically perform SQL queries of the form:

\vspace{0.3cm}
\texttt{SELECT total\_bill, tip FROM tips} \\
\hspace*{1cm} \texttt{WHERE smoker IN clickSelects}
\vspace{0.3cm}

In this example, \texttt{clickSelects} is either "Yes" or "No", but as we show in later examples, \texttt{clickSelects} can also be an array of values. Although \texttt{clickSelects} is tied to a mouseclick event, this same framework supports other selection events, such as hover or click+drag. Statistically speaking, this is useful for visualizing and navigating through joint distributions conditional upon discrete values. In this sense, our extension is closely related to the same a basis which leads to trellis displays \citep{trellis} and linked scatterplot brushing \citep{brushing-scatterplots}. The major difference are that conditioning: is layer (i.e., not plot) specific, is not tied to a particular geometry, and can be controlled through direct manipulation or animation controls.
%% TODO: make connections to scagnostics? trelliscope?

\subsection{Adding animation}
\label{sec:animation}

In some sense, the \texttt{showSelected} aesthetic splits the layer into subsets -- one for every unique value of the \texttt{showSelected} variable. The \texttt{clickSelects} aesthetics provides a mechanism to alter the visibility of those subset(s) via direct manipulation, but our animint implementation can also loop through selections to produce animation(s). We acheive this by reserving the name \texttt{time} to specify which variable to select as well as the amount of time to wait before changing the selection (in milliseconds). We also reserve the name \texttt{duration} to specify the amount of time used to smoothly transition between frames (with linear easing). The code below was used to generate Figure~\ref{fig:animation} which demonstrates a simple animation with smooth transitions between 10 frames of a single point. Note that the resulting web page has controls for interactively altering the \texttt{time} and \texttt{duration} parameters. 

<<>>=
d <- data.frame(v = 1:10)
plotList <- list(
  plot = ggplot() + geom_point(
    data = d, aes(x=v, y=v, showSelected=v)
  ),
  time = list(variable = "x", ms = 1000),
  duration = list(x = 1000)
)
animint2dir(plotList)
@


\begin{figure}[htp]
	\centerline{\includemovie[poster={animation.png}, text={}]{150pt}{200pt}{animation.mov}}
	\label{fig:animation}
	\caption{Video demonstrating a simple animation with smooth transitions and interactively altering transition durations. You can view this movie by opening the pdf document with Adobe Reader and clicking on the figure above, or view it online at \url{https://vimeo.com/160505146}}
\end{figure}


\subsection{World Bank Example}
\label{sec:design}

%% In the system we propose, the central concept of interactivity is a
%% selection variable, such as year or region in Figure~1. For each
%% selection variable, one or several values can be selected at a time,
%% e.g. year=1979 and country=\{United States, Vietnam\}.  Like
%% Cleveland's system, we also use enhanced linking to highlight the
%% selected value(s) of each selection variable. In contrast to
%% Cleveland's single rectangular brush that selects points in plots of a
%% single data table, we propose several selection variables in linked
%% plots of several data tables. Linking is accomplished using common
%% names when declaring \texttt{clickSelects} and \texttt{showSelected}
%% selection variables.

%% For example, to declare a clickable plot element that changes the
%% selected value of the year variable, a designer writes
%% \texttt{clickSelects=year} (tallrect in Figure~1). And to show only
%% the data subset for the selected value of year, a designer writes
%% \texttt{showSelected=year} (point and text in Figure~1).

%% Using just the \texttt{clickSelects} and \texttt{showSelected}
%% keywords, a wide variety of interactive visualizations can be
%% defined. To make the selection automatically change over time
%% (animation), a designer may declare one variable as the \texttt{time}
%% variable. Since it is perceptually advantageous to have smooth
%% transitions in data-driven animations \citep{animated-transitions}, a
%% designer may also declare a \texttt{duration} list of selection
%% variables which should have smooth transitions.

Figure~\ref{fig:worldbank} shows an interactive animation of the World Bank
data set \citep{WorldBank} created with our animint implementation. The 
visualization helps us explore the change in the relationship between life 
expectancy and fertility over time for 205 countries. By default, the year 
1979 and the countries United States and Vietnam are
selected, but readers are encouraged to watch the video of the animation 
and/or interact the visualization using a web 
browser.\footnote{\url{http://bl.ocks.org/tdhock/raw/8ce47eebb3039263878f/}}
In the interactive version, the selected value of the year variable is
automatically incremented every few seconds, using animation to
visualize yearly changes in the relationship between life expectancy
and fertility rate.

\begin{figure*}[htp]
  \centering
  \includegraphics[width=\textwidth]{figure-1}
  \caption{An interactive animation of World Bank demographic data of
    several countries, designed using \texttt{clickSelects} and
    \texttt{showSelected} keywords (top).  \textbf{Left}: a multiple
    time series from 1960 to 2010 of life expectancy, with bold lines
    showing the selected countries and a vertical grey tallrect
    showing the selected year. \textbf{Right}: a scatterplot of life
    expectancy versus fertility rate of all countries. The legend and
    text elements show the current selection: year=1979,
    country=$\{\textrm{United States}, \textrm{Vietnam}\}$, and
    region=$\{\textrm{East Asia \& Pacific}, \textrm{North
      America}\}$}
  \label{fig:worldbank}
\end{figure*}

We anticipate that some ggplot2 users will be able to reverse engineer the
animint code which creates Figure~\ref{fig:worldbank}, simply by looking at it.
In fact, this is one of the wonderful things about ggplot2, it helps minimize 
the amount of time required to translate a figure in your head into code 
(TODO: more on this in section X). In the left hand plot, 
we have a time series of the life expectancy where
each line (\texttt{group}) is a country and lines are \texttt{color}ed by 
region. By clicking on a line, we want the country label to appear
in the right hand plot, so we also need to set \texttt{clickSelects=country}. 
Lastly, by setting \text{showSelected=region} we can hide/show lines
by clicking on the color legend entries.

<<lifeLines>>=
timeSeries <- ggplot() + geom_line(
  data = WorldBank,
  aes(x = year, y = life.expectancy,
      group = country, color = region,
      clickSelects = country, 
      showSelected = region)
)
@

We want to provide a visual clue for the selected year in the 
time series, so we also layer some ``tall rectangles" onto the time series.
These tall rectangles will also serve as a way to directly modify the 
selected year. The tallrect geometry is a special case of a rectangle
that automatically spans the entire vertical range, so we just have to 
specify the horizontal range via \texttt{xmin} and \texttt{xmax}. Also, 
since the layered grammar of graphics allows for different data in 
each layer, we supply a data frame with just the unique years in the 
entire data for this layer.

<<yearRects>>=
years <- data.frame(year = unique(WorldBank$year))
timeSeries <- timeSeries + geom_tallrect(
  data = years,
  aes(xmin = year - 0.5, xmax = year + 0.5,
      clickSelects = year)
)
@

As for the right hand plot in Figure~\ref{fig:worldbank}, there are 
three layers: a point layer for countries, a text layer for countries, 
and a text layer to display the selected year. By clicking on a point,
we want to display the country text label and highlight the corresponding
time series on the right hand plot, so we set \texttt{clickSelects=country}
in this layer. Furthermore, we only want to show the points for the 
selected year and region, so we also need \texttt{showSelected=year} and 
\texttt{showSelected2=region}.

<<countryPoints>>=
scatterPlot <- ggplot + geom_point(
  data = WorldBank,
  aes(x = fertility.rate, y = life.expectancy,
      color = region, size = population,
      clickSelects = country,
      showSelected = year,
      showSelected2 = region)
)
@

The text layer for annotating selected countries looks quite similar to the 
point layer with a few important differences:

<<countryText>>=
scatterPlot <- scatterPlot + geom_text(
  data = WorldBank,
  aes(x = fertility.rate, y = life.expectancy,
      label = country,
      showSelected = country,
      showSelected2 = year,
      showSelected3 = region)
)
@

Lastly, to help identify the selected year when viewing the scatterplot, 
we add another layer of text at a fixed location.

<<yearText>>=
scatterPlot <- scatterPlot + geom_text(
  data = years, x = 5, y = 80,
  aes(label = paste("year =", year),
      showSelected = year)
)
@

Now that we have defined the plots in Figure~\ref{fig:worldbank}, we can set
the \texttt{time} and \texttt{duration} options (introduced in Section~\ref{sec:animation}) to control the animation parameters. Our animint implementation also respects a \texttt{selector.types} option which controls whether or not selections for a given variable can accumulate.\footnote{We maintain a complete list of options here -- \url{https://github.com/tdhock/animint/wiki/Advanced-features-present-animint-but-not-in-ggplot2}} By default, supplying the list of 
plots and additional options to 
\texttt{animint2dir()} will write all the files necessary to render 
the visualization to a temporary directory and prompt the browser to 
open the relevant HTML file.

<<viz,fig.pos='htbp'>>=
viz <- list(
  timeSeries = timeSeries,
  scatterPlot = scatterPlot,
  time = list(variable = "year", ms = 3000),
  duration = list(year = 1000),
  selector.types = list(
    year = "single",
    country = "multiple",
    region = "multiple"
  )
)
animint2dir(viz)
@


%% TODO: this bit down here seems a bit out of place. Add to it and put in it's own section?
Direct manipulation is useful when it is easy to identify and select 
a graphical marks on a plot, but that is not always easy. In these cases,
it is convenient to have a dropdown menu to aid the selection process.
For this reason, the animint system automatically provides selection 
menu(s) for each \texttt{showSelected} variable. 
For an example, suppose that we would like select a country by name in
Figure~\ref{fig:worldbank}. Figure~\ref{fig:widgets} shows what the user
sees after typing ``th'' in the search box. 

\begin{figure}[htp]
  \centering
  \includegraphics[width=0.5\columnwidth]{Screenshot-toggle-selected-value}
  \caption{Animint provides a menu to update each selection
    variable. In this example, after typing ``th'' the country menu
    shows the subset of matching countries.}
  \label{fig:widgets}
\end{figure}

\subsection{Implementation details}
\label{sec:implementation}

As shown in Figure~\ref{fig:design}, the animint system is implemented
in 2 parts: the compiler and the renderer. The compiler is implemented in about 
2000 lines of R code that converts a list of ggplots and options to a JSON 
plot meta-data file and a tab-separated values (TSV) file database
(Figure~\ref{fig:design}).

\begin{figure}[htp]
  \centering
  \includegraphics[width=\columnwidth]{figure-design}
  \caption{Schematic explanation of compilation and rendering the
    World Bank visualization shown in Figure~1. \textbf{Top}: the
    interactive animation is a list of 4 R objects: 2 ggplots and 2
    option lists. \textbf{Center}: animint R code compiles data in
    ggplot geoms to a database of TSV files
    (\textcolor{red}{$\rightarrowtriangle$}). It also compiles plot
    meta-data including ggplot aesthetics, animation time
    options, and transition duration options to a JSON meta-data file
    ($\rightarrowtriangle$). \textbf{Bottom}: those data-dependent
    compiled files are combined with data-independent JavaScript and
    HTML files which render the interactive animation in a web browser
    (\textcolor{blue}{$\rightarrowtriangle$}).}
  \label{fig:design}
\end{figure}

\begin{figure*}[htp]
  \centering
  \includegraphics[width=\textwidth]{figure-tornado}
  \caption{Interactive animation of tornadoes recorded from 1950 to
    2012 in the United States. \textbf{Left}:
    map of the lower 48 United States with tornado paths in 1982. The
    text shows the selected year, and clicking the map changes the
    selected state, currently Texas. \textbf{Right}: time series of
    tornado counts in Texas. Clicking a bar changes the selected year,
    and the text shows selected state and the number of tornadoes
    recorded there in that year (119 tornadoes in Texas in 1982).}
  \label{fig:tornado}
\end{figure*}

\begin{figure*}[htp]
  \centering
  \includegraphics[width=\textwidth]{figure-climate}
  \caption{Visualization containing 6 linked, interactive, animated
    plots of Central American climate data. \textbf{Top}: for the selected time
    (December 1997), maps displaying the spatial distribution of two
    temperature variables, and a scatterplot of these two
    variables. The selected region is displayed with a black outline,
    and can be changed by clicking a rect on the map or a point on the
    scatterplot. \textbf{Bottom}: time series of the two temperature
    variables with the selected region shown in violet, and a
    scatterplot of all times for that region. The selected time can be
   changed by clicking a background tallrect on a time series or a
    point on the scatterplot. The selected region can be changed by
    clicking a line on a time series.}
  \label{fig:climate}
\end{figure*}


The compiler scans the aesthetics in the ggplots to determine
how many selection variables are present, and which geoms to update
after a selection variable is updated. It uses ggplot2 to
automatically calculate the axes scales, legends, labels, backgrounds,
and borders. It outputs this information to the JSON plot meta-data
file.

The compiler also uses ggplot2 to convert data variables (e.g. life
expectancy and region) to visual properties (e.g. y position and
color). The data for each layer/geom are saved in several TSV files,
one for each combination showSelected values. Thus for large data
sets, the web browser only needs to download the subset of data
required to render the current selection \citep{2013-immens}.

When repeated data would be saved in each of the TSV files, an extra
common TSV file is created so that the repeated data only need to be
stored and downloaded once. In that case, the other TSV files do not
store the common data, but are merged with the common data after
downloading. This method for constructing the TSV file database was
developed to minimize the disk usage of animint, particularly
for ggplots of spatial maps as in Figure~\ref{fig:tornado}.

Finally, the rendering engine (\texttt{index.html}, \texttt{d3.v3.js},
and \texttt{animint.js} files) is copied to the plot directory. The
\texttt{animint.js} renderer is implemented in about 2200 lines of
JavaScript/D3 code that renders the TSV and JSON data files as SVG in
a web browser. Importantly, animation is achieved by using the
JavaScript \texttt{setInterval} function, which updates the
\texttt{time} selection variable every few seconds. Since the compiled
plot is just a directory of files, the interactive plots can be hosted
on any web server. The interactive plots can be viewed by opening the
\texttt{index.html} page in any modern web browser.

\section{Comparison study}
\label{sec:compare}

To compare our animint implementation with similar leading systems, we 
reimplemented Figure~\ref{fig:worldbank} using Tableau as well as
the R packages animation and ggvis. We also walk through examples of
the grand tour with both animint and ggvis which helps point out 
important consequences of each design approach.

\subsection{World Bank Example}

% TODO: condense this section

As shown in Table~\ref{tab:packages}),
animint requires significantly fewer lines of code and produces
interactive plots with more articulatory directness
\citep{Hutchins:1985}. Note that it is possible to implement the World
Bank visualization in pure D3, but would require significantly more code.


We designed a version of the WorldBank visualization with limited
interactivity, using 38 lines of R code and the animation
package. The main idea behind this approach is to use an imperative
programming style with for loops to create a static PNG image for each
year of the data, and then show these images in sequence. The main
drawback to this approach is that the resulting plot is only
interactive with respect to the year variable. In other words, the
designer must select some countries to emphasize, and the user can not
change that selection. Another drawback is that R package
animation does not support smooth transitions between
animation frames. In contrast, using only 20 lines of the animint DSL,
the animint package achieves smooth transitions and interaction with
respect to both year and country variables.

\begin{table}[t!]
%% Table captions on top in journal version
  \caption{Implementation complexity and features
    of the World Bank data visualization
    %of Figure~1
    using several libraries that can create interactive animations.
    For each library
    we show the number of lines of code (LOC), the on-screen objects
    that can be clicked,  the
    number of interaction variables, and URL of the interactive version.
%  Note that different countries can not be interactively selected using
% the visualization created with R package animation.
% The URLs are missing.
  }
 \label{tab:packages}
% \scriptsize
 \begin{center}
  \begin{tabular}{cccccc}
    library & LOC & click on & interaction vars \\
    \hline
    animint     & 20 & plotted data & several \\
    animation   & 38 & play/pause & 1 = time \\
    ggvis/shiny & 84 & widgets & several \\
    Tableau    &    & widgets/plot & several \\
  \end{tabular}
 \end{center}
\end{table}

We designed another version of the World Bank data visualization in 115
lines of R code (\url{http://bit.ly/1SsJKlN}), using the ggvis
graphics library combined with the recommended shiny web server
package \citep{shiny, ggvis}. Showing and hiding data subsets was
accomplished by clicking on a slider for year and a menu for country,
not by clicking on the plot elements. In contrast, we designed
Figure~\ref{fig:worldbank} using only 20 lines of R code with 
the animint package.

The two packages also have different features for interacting with a
data visualization: ggvis uses sliders, checkboxes, and other HTML
form elements, whereas animint users can directly click the SVG
elements that are used to visualize the data. For example, a ggvis of
the WorldBank data would animate over the years by adding a play/pause
button to a slider widget which controls the selected year. In
contrast, in animint we used a multiple time series plot where the
year can be selected by directly clicking the data values on the plot
(Figure~1). The animint plot is thus easier for the user since it has
more articulatory directness \citep{Hutchins:1985}, and less spatial
offset \citep{instrumental-interaction}.

Another difference is the amount of work required to deploy or share a
visualization. A compiled animint visualization consists of static
TSV, JSON, HTML, and JavaScript files which can be easily served with
any web server. In contrast, ggvis+shiny requires a web server with R
and special software installed, significantly complicating
deployment to the web.

There are also inherent speed tradeoffs to using a client-server
plotting system like ggvis+shiny rather than an entirely web
client/JavaScript-based system like animint. There is one main
difference between these two types of systems that affects
responsiveness of a web-based interactive plotting system:
client-server communication overhead. All the animint
JavaScript plot rendering code is executed in the web browser, whereas
ggvis executes some computations on the server. This means that after
a mouse click, ggvis can not update a plot immediately, but instead
must wait for the server to respond with the plot data.

We quantified speed differences between the two systems by timing web
page loading using DevTools in the Chromium web browser Version
33.0.1750.152, on Ubuntu 12.04 (256984). We also used \texttt{getTime()}
in JavaScript to record timings for interactive plot updates (on a
desktop computer with a 2.8GHz Intel Core i7 CPU). Using ggvis with a
local web server and the World Bank data resulted in a web page that
loaded quickly (about 1.4s), but updated the plot with a noticeable
lag after each mouse click (500--1000ms). Note that since we used a
local web server, these times represent the overhead of the web server
system, and would be larger with a remote web server.

\begin{table*}[htp] % This table is too wide to fill in the page.
  \centering
  \input{table-examples}
  \vskip 0.2cm
  \caption{Characteristics of 11 interactive visualizations designed with
    animint. From left to right, we show the data set name, the
    lines of R code (LOC) including data processing but not including comments
    (80 characters max per line),
    the amount of time it takes to compile the visualization (seconds),
    the total size of the uncompressed TSV files in megabytes (MB),
    the total number of data points (rows),
    the median number of data points shown at once (onscreen),
    the number of data columns visualized (variables),
    the number of \texttt{clickSelects}/\texttt{showSelected} variables (interactive),
    the number of linked panels (plots),
    if the plot is animated,
    and the corresponding Figure number in this paper (Fig).
  }
\label{tab:examples}
\end{table*}

When we used animint to make the World Bank data visualization, the
compilation from R objects to 2.1MB of uncompressed TSV data files
took 2.3s. Using a local web server, the animint JavaScript rendered
the plot very quickly (100--200ms). We also observed very fast plot
updates after mouse clicks in animint: 20--30ms response times for
selecting the year, and 60--70ms response times for selecting the
country.
%Furthermore, in web server systems the client may not cache
%previously viewed subsets, which results in calculations inefficiently
%being performed several times rather than simply saved for quick
%viewing later.

The conclusion of our speed comparison is that the overhead of waiting
for a web server to perform computations results in significant
slowdowns for interactive animations. It is clear that for quick
response times, it is preferable to use an entirely JavaScript-based
system like animint.

In contrast, a web server system like ggvis+shiny would be more
appropriate for
%  interactive animations that have many more subsets of
% the data than can ever be transferred over the network. In that case,
% the web server will initially send only the first data subset, and
% then send only the subsets of data that the client requests. However,
% since the data sets we examined were not too large
% (Table~\ref{tab:examples}), client-side rendering using Animint
% resulted in quick, responsive interactive animations.
% Another application for which a web server system like ggvis+shiny
% would be preferable is for
performing arbitrary calculations in R/C code on the server, in
response to user inputs, and then sending the result across the
network for plotting in the user's web browser. This power is not
always necessary for interactive animations, since the only operation
needed is showing precomputed data subsets. However, the web server
system would certainly be preferable when there are many more data
subsets than could ever be precomputed. In that case, the web server
would only compute the subsets that the user interactively specifies.

We implemented a version of the WorldBank data visualization using
Tableau's GUI (\url{http://bit.ly/worldBank-tableau}).
%% TDH 20 Nov 2014: When I click on a country on the scatterplot it
%% does not select that country's time series --- is that an inherent
%% limitation of Tableau that we should discuss?
It was impossible to implement all features of the multiple time
series plot of the data visualization, since it includes multiple
layers with different data sources and variable mappings (a line for
each country and a tallrect for each year). Since each mark in a
Tableau plot must use the same data source, it was impossible to
control the clickable multiple time series and the clickable tallrects
in different ways based on the two different selection variables.

Tableau's GUI and visual query approach
make it easy to design several kinds of linked plots, but it does not
easily acheive the same level of flexibility that our
layered grammar of graphics extension provides. More specifically, it allows
for each layer of geoms in a plot to have a different data source and
variable mapping, while Tableau requires each mark of a plot to be a
function of a single query result. This results in a substantial
conceptual difference between the selection models of Tableau and animint. In Tableau, there is a selection set for each plot, which may
include several different marks. In contrast, animint keeps track of a
selection set for each selection variable, each of which has
geom-specific effects based on the geom's \texttt{clickSelects}/\texttt{showSelected}
variables.

\subsection{The Grand Tour}

\begin{figure}[htp]
	\centerline{\includemovie[poster={tour.png}, text={}]{250pt}{120pt}{tour.mov}}
	\label{fig:tour}
	\caption{Video demonstrating a grand tour with linked selection. You can view this movie by opening the pdf document with Adobe Reader and clicking on the figure above, or view it online at \url{https://vimeo.com/160720834}}
\end{figure}


In this section we discuss the range of examples that we have designed
with animint. Table~\ref{tab:examples} shows several characteristics
of 11 interactive visualizations that we have designed using
animint.

We quantified the implementation difficulty of the animint examples
using lines of R code, including data processing but not including
comments (80 characters max per line). We counted the number of plots
and variables shown to quantify the amount of information conveyed by
the visualization. Using only 17 lines of code, we designed a simple
visualization that shows 2 linked plots of 4 variables in the worldPop
data set. In contrast, the most complex visualization required 229
lines of code, and it shows 44 variables across 5 linked plots
(Figure~\ref{fig:ChIPseq}). All of the visualizations that we designed
involved at least 2 interaction variables (e.g. year and country in
Figure~1) and 2 plots. Indeed, animint is most appropriate for
interactive visualizations of multivariate data that are not easy to
view all at once in one plot.

Table~\ref{tab:examples} also shows animint system requirements for
plots of various sizes. We timed the compilation step in R code
(``seconds'' column), and measured the size in megabytes of the
compiled TSV file database (``MB'' column), and found that both
increase with the data set size (``rows'' column).
%Although we do not present timings for the rendering step,
We also noticed that the time required for the interactive updates and
rendering increases with the amount of data displayed at once
(``onscreen'' column). In particular, the climate data visualization
has noticeably slow animations, since it displays about 88,980
geometric elements at once (\url{http://bit.ly/QcUrhn}). We observed
this slowdown across all browsers, which suggested that there is an
inherent bottleneck when rendering large interactive plots in web
browsers using JavaScript and SVG. Another animint with a similar
amount of total rows is based on the evolution data
(\url{http://bit.ly/O0VTS4}), but since it shows less data onscreen
(about 2703 elements), it exhibits faster responses to interactivity
and animation.

\subsection{Animated examples}

Figure~\ref{fig:tornado} shows an interactive animation of tornadoes
observed in the United States between 1950 and 2012. At any moment in
time, the user can simultaneously view the spatial distribution of
tornadoes in the selected year over all states, and see the trend over
all years for the selected state. Clicking a state on the map updates the
time series bars to show the tornado counts from that state. Clicking
a bar on the time series updates the selected year.

Figure~\ref{fig:climate} shows an interactive animation of climate
time series data observed in Central America. Two maps display the
spatial distribution of two temperature variables, which are shown
over time in corresponding the time series plots below. Scatterplots
also show the relationships between the two temperature variables for
the selected time and region. Clicking any of the plots updates all 6
of them. The \texttt{clickSelects} and \texttt{showSelected} aesthetics make it easy to
design this set of 6 linked plots in only 87 lines of code.
%% Animint's
%% DSL allows for this level of flexibility while using minimal lines of
%% code to define the plots and the relationship between them.

\subsection{Non-animated examples}

Animint is still useful for creating interactive but
non-animated plots when there is not a time variable in the data.
In fact, 7 of the 11 examples in
Table~\ref{tab:examples} are not animated. For example, linked plots
are useful to illustrate complex concepts such as a change point
detection model in the breakpoints data
(\url{http://bit.ly/1gGYFIV}). The user can explore different model
parameters and data sets since these are encoded as animint
interaction variables.

\section{User feedback and observations}

By working with researchers in several fields of research,
we have created a wide variety of
interactive visualizations using animint.
Typically, the researchers have a complex data set that
they wish to visualize,
but they do not have the expertise or time to create
an interactive data visualization.
The animint DSL made it easy to collaborate with the various domain experts,
who were able to provide us with annotated sketches of the desired plots,
which we then translated to animint R code.
In this section we share comments and
constructive criticism that we have obtained from our users.

\subsection{User perspective}

For the \texttt{prior} data visualization
(\url{http://bit.ly/1peIT7t}), the animint user is a machine learning
researcher who developed an algorithm and applied it to 4 benchmark
data sets. He wanted to explore how his algorithm performed, in
comparison to a baseline learning algorithm. He appreciated the
intuition about his algorithm's performance that he learned from the
interactive plots: ``Interactive plotting allows us to explore all
relationships of our high-dimensional dataset and gives us an
intuitive understanding of the performance of our proposed
algorithm. An intuitive understanding of the results is important
since it shows under which conditions our proposed method works well
and provides avenues for further research.''

Another user from a machine learning background found the interactive
plots useful for presenting his work: ``the `regularization path' is a
difficult concept to demonstrate in my research. The animint
(\url{http://bit.ly/1gVb8To}) helped greatly by rendering an
interactive plot of regularization path, likelihood, and graph at the
same time and illustrating their connections. It also reveals an
interesting phenomenon that maximizing the testing likelihood actually
gives many false positives.''

In another application, the animint user was a genomics researcher:
``viewing and exploring my complex intestinal microbiome dataset in
animint allowed me to grasp the patterns and relationships between
samples at an almost intuitive level. The interactive aspect of it was
very helpful for browsing through the dataset.''

Finally, users also appreciated the simple web interface, and the
detail that is possible to show in interactive plots, but impossible
to show in publications: ``...  the web interface is simple and easy
to use.  It also enables us to publish more detailed interactive
results on our website to accompany the results presented in
publications.''

\subsection{Developer perspective}

R users, and in particular ggplot2 users, have found that animint 
is easy to learn and use. One statistics Ph.D. student writes, 
``animint is a fantastic framework for creating
interactive graphics for someone familiar with R and ggplot2's grammar
of graphics implementation. The API is very intuitive and allows one
to quickly bring their static graphics to life in a way that
facilitates exploratory data analysis.''

\section{Discussion}

%% TODO: this paragraph below doesn't warrant a discussion. Find some other place to put it.

Finally, another key strength of ggplot2 and D3 for visualization
design are the libraries' declarative syntax, which allows a
visualization designer to specify \emph{what} they want to render
rather than \emph{how} to render it. \citet{declarative} proposed a
declarative syntax for animated transanitions, and studied the
benefits of declarative languages for data visualization. animint is
another declarative DSL, but defined at a higher level of abstraction
than D3. It enables designers to focus on data visualization, while
the animint library developers can work on improving the lower-level
rendering details.

\section{Limitations and future work}

%%The clickSelects/showSelected paradigm is fundamentally a tool for show and hiding subsets of a dataset. For this reason, interactions used to change chart types or select parameters values, turn out to be inefficient, if not impossible.

There are several limitations to the animint system, which suggest
avenues for future work. Some limitations are specific to the current
implementation as research software, and some limitations are inherent
in the \texttt{clickSelects}/\texttt{showSelected} keywords.

\subsection{Limitations of current implementation}

animint implements several linked plots, one of the hallmarks of
interactive visual analysis \citep{iva}. However, one limitation to
the current implementation is that a selection is defined as a set of
distinct elements (e.g. year=\{1991, 1992\}) rather than a logical
expression (e.g. year $>1990$). Also, animint does not yet
implement a rectangular brush for specifying values of
multiple selection variables.
Importantly, these are drawbacks of the
current implementation, not the animint DSL.

A number of limitations derive from the fact that some plot elements
are computed once during the compilation step and remain static on a
rendered plot. For example, users are unable to change variable
mappings since these are specified by the designer at compile
time. Also, when different data subsets have very different ranges of
values, it may be preferable to recompute scales when
\texttt{clickSelects} selection(s) change. A workaround is shown in
Figure~\ref{fig:ChIPseq}, which omits the x axis on the bottom plot,
since in fact the x values are all normalized to [0,1]. A future
implementation of animint would benefit from changes to the compiler
and renderer that allow scales to be updated after each click.

Some animint limitations can be resolved by animint designers who are
familiar with the shiny web server R package \citep{shiny}.  animint
provides ``shiny bindings'' which enables a designer to embed an
animint plot within a shiny app without writing any HTML or
JavaScript, which allows a user to re-compile an animint from a web
browser. For example, we implemented a shiny app in which users can
redefine variable mappings (\url{http://bit.ly/animint-shiny}).

As discussed in Section~\ref{sec:design} and illustrated in
Figure~\ref{fig:design}, the compiler is written in R, and the
renderer is written in JavaScript.
%% This means that Animint developers must be proficient in both R and
%% JavaScript. This represents a significant barrier for source code
%% contributions from developers who are proficient with one language
%% but not the other.
animint designers define interactive animations using only R code, and
no knowledge of JavaScript is necessary. This is convenient for useRs
from a statistical background, but presents a barrier for web
developers who are more familiar with JavaScript than R. For these web
developers, it would be advantageous in the future to implement a
compiler and renderer in pure JavaScript, by possibly building
\texttt{clickSelects} and \texttt{showSelected} extensions into Vega
\citep{vega}.

The current animint implementation is limited to two specific types of
interactivity: highlighting the selected \texttt{clickSelects}
element, and showing/hiding \texttt{showSelected} elements. In the
future, we could implement several other types of interactivity
without changing the animint DSL. Examples include zooming,
panning, and plot resizing. However, some
kinds of interactivity would require extensions to the animint
grammar. For example, a \texttt{hoverSelects} aesthetic
could be used to change the selection when hovering over a data point.

\subsection{Limitations of \texttt{clickSelects}/\texttt{showSelected} keywords}

TODO. discuss that grand tours are awkward in animint since each
animation frame must be pre-computed, and there are many more possible.
It's not that they can't be computed beforehand. But if you have a
large amount of projections that you want to view, that could be a
bottleneck \citep{tourr}. The grand tour picks random projections, so
I'm pretty sure the number of projections is infinite in the
mathematical sense. But there are also guided tours that pick
"interesting" projections.

TODO: discuss two main failure modes: 1. you really want to compute
something on the fly (like a random projection) and 2. with multiple
selection variables, there are too many items in the power set so they
can't all be computed in advance.

TODO: discuss conditioning on quantitative variables? any concrete
example plots where this would be useful?

TODO: distinction between the \texttt{clickSelects}/\texttt{showSelected} keywords and
the animint system which pre-computes everything? Could there be a
\texttt{clickSelects}/\texttt{showSelected} system which does NOT pre-compute
everything?

Since animint does not perform any computations other than showing and
hiding data subsets, there is a limitation to what can be
displayed with multiple selection variables.
The limitation is that it is not feasible to precompute
something to display for each of the combinatorial number of
possible selections
of a multiple selection variable.
For instance, in the
WorldBank visualization of Figure~1, it would not be feasible to
display a single smoothing line computed from all the selected
countries. This is because \texttt{showSelected=country} means to show
one thing for each selected country (not one thing computed based on
the set of selected countries). Supporting this kind of interaction
would require substantial modifications to the animint system,
including adding the ability to perform computations on
multiple selection variable sets.

TODO: revise paragraph. animint's performance can be measured using
speed, memory, and disk space requirements in the compilation and
rendering steps. Although we showed in Section~\ref{sec:compare} that
animint provides smoother interactivity than client-server systems,
future versions of animint could be made even more efficient and
responsive. For example, of the plots in Table~\ref{tab:examples}, the
longest compilation step took 56.3 seconds, which may be reduced by
optimizing the R code compiler.

This highlights one of the main motivations for using a declarative
DSL like animint: none of the designer's R code needs to be changed to
implement improvements like this. Instead, the animint developers just
need to work on a better compiler and rendering engine. Indeed,
\citet{declarative} noted that this is one of the main benefits of
declarative language design: ``By decoupling specification from
implementation, developers can implement language optimizations
without interfering with the work of designers.''

While several
optimizations remain to be implemented, the current animint library
already provides an efficient syntax for the design of interactive,
animated data visualizations.

In the future, I'd be interesting in trying to "solve" (1) for some
class of problems where you want some elements to have smooth
transitions when new data arrives.

\section*{Acknowledgements}

The authors wish to thank animint users MC Du Plessis, Song Liu,
Nikoleta Juretic, and Eric Audemard
who have contributed constructive criticism and helped its development.

% TDH 13 March 2014 This was in the template.tex file.
%\bibliographystyle{abbrv}

\bibliographystyle{abbrvnat}

%%use following if all content of bibtex file should be shown
%\nocite{*}
\bibliography{refs} % There should be a linebreak for Tableau reference.
\end{document}
