\documentclass[journal]{vgtc}                % final (journal style)
%\documentclass[review,journal]{vgtc}         % review (journal style)
%\documentclass[widereview]{vgtc}             % wide-spaced review
%\documentclass[preprint,journal]{vgtc}       % preprint (journal style)
%\documentclass[electronic,journal]{vgtc}     % electronic version, journal
\usepackage{color}
\usepackage{stmaryrd}
\usepackage{stfloats}
%% Uncomment one of the lines above depending on where your paper is
%% in the conference process. ``review'' and ``widereview'' are for review
%% submission, ``preprint'' is for pre-publication, and the final version
%% doesn't use a specific qualifier. Further, ``electronic'' includes
%% hyperreferences for more convenient online viewing.

%% Please use one of the ``review'' options in combination with the
%% assigned online id (see below) ONLY if your paper uses a double blind
%% review process. Some conferences, like IEEE Vis and InfoVis, have NOT
%% in the past.

%% Please note that the use of figures other than the optional teaser is not permitted on the first page
%% of the journal version.  Figures should begin on the second page and be
%% in CMYK or Grey scale format, otherwise, colour shifting may occur
%% during the printing process.  Papers submitted with figures other than the optional teaser on the
%% first page will be refused.

%% These three lines bring in essential packages: ``mathptmx'' for Type 1
%% typefaces, ``graphicx'' for inclusion of EPS figures. and ``times''
%% for proper handling of the times font family.
\usepackage{natbib}
\usepackage{mathptmx}
\usepackage{graphicx}
\usepackage{times}
%% We encourage the use of mathptmx for consistent usage of times font
%% throughout the proceedings. However, if you encounter conflicts
%% with other math-related packages, you may want to disable it.

%% This turns references into clickable hyperlinks.
\usepackage[bookmarks,backref=true,linkcolor=black]{hyperref} %,colorlinks
\hypersetup{
  pdfauthor = {},
  pdftitle = {},
  pdfsubject = {},
  pdfkeywords = {},
  colorlinks=true,
  linkcolor= black,
  citecolor= black,
  pageanchor=true,
  urlcolor = black,
  plainpages = false,
  linktocpage
}

\newcommand{\bitly}[1]{\href{http://bit.ly/#1}{\texttt{#1}}}

%% If you are submitting a paper to a conference for review with a double
%% blind reviewing process, please replace the value ``0'' below with your
%% OnlineID. Otherwise, you may safely leave it at ``0''.
\onlineid{0}

%% declare the category of your paper, only shown in review mode
\vgtccategory{Research}

%% allow for this line if you want the electronic option to work properly
\vgtcinsertpkg

%% In preprint mode you may define your own headline.
%\preprinttext{To appear in an IEEE VGTC sponsored conference.}

%% Paper title.

\title{Animint: a Grammar for Interactive Animations}

%% This is how authors are specified in the journal style

%% indicate IEEE Member or Student Member in form indicated below
\author{Toby Dylan Hocking and Susan VanderPlas}
\authorfooter{
%% insert punctuation at end of each item
\item
 Toby Dylan Hocking is with McGill Human Genetics. E-mail: toby.hocking@mail.mcgill.ca.
\item
 Susan VanderPlas is with Iowa State Statistics. E-mail: srvanderplas@gmail.com.
}

%other entries to be set up for journal
\shortauthortitle{Hocking \MakeLowercase{\textit{et al.}}: Animint: a
  Grammar for Interactive Animations}
%\shortauthortitle{Firstauthor \MakeLowercase{\textit{et al.}}: Paper Title}

%% Abstract section.
\abstract{Animint is a novel high-level domain-specific language (DSL)
  for linked, interactive, animated plots. It builds on top
  of previous work on the grammar of graphics (ggplot2 in R) and
  interactive visualization using web standards (D3 in JavaScript). In
  other data visualization systems, interactive animations are
  difficult to accomplish, since they must be defined in terms of
  low-level operations and sometimes 100s of lines of code. In
  contrast, Animint's high-level DSL can be used to produce a wide
  variety of complex interactive visualizations with only 10s of lines
  of code. It works by adding 2 new aesthetics to the grammar of
  graphics: \texttt{clickSelects}, which allows users to select
  elements of the plot, and \texttt{showSelected}, which displays only
  elements corresponding to the current selection. After using our
  novel declarative DSL to define an interactive animation in R code,
  it is first compiled and then rendered in a web browser using D3. We
  discuss the design of Animint, then compare to related libraries,
  and show several example visualizations of high-dimensional time
  series data.} % end of abstract

%% Keywords that describe your work. Will show as 'Index Terms' in journal
%% please capitalize first letter and insert punctuation after last keyword
\keywords{Information visualization, user interfaces, toolkits, 2D
  graphics, interactive, animation}

%% ACM Computing Classification System (CCS). 
%% See <http://www.acm.org/class/1998/> for details.
%% The ``\CCScat'' command takes four arguments.

\CCScatlist{ % not used in journal version
 \CCScat{K.6.1}{Management of Computing and Information Systems}%
{Project and People Management}{Life Cycle};
 \CCScat{K.7.m}{The Computing Profession}{Miscellaneous}{Ethics}
}

%% Uncomment below to include a teaser figure.
  \teaser{
  \centering
  \includegraphics[width=\textwidth]{figure-1}
  \caption{Interactive animation of World Bank data designed with Animint
    (\url{http://bit.ly/1fzfUdN}). \textbf{Top}: There are 5 geometric
    elements across 2 linked plots: clicking a \texttt{clickSelects}
    element changes the currently selected year or country, and
    updates the corresponding \texttt{showSelected}
    elements. \textbf{Left}: a multiple time series from 1960 to 2012
    of the life expectancy of 205 countries, with a bold line
    indicating the selected country and a vertical grey tallrect
    indicating the selected year.  \textbf{Right}: a scatterplot of
    life expectancy versus fertility rate of all countries. The two
    text elements indicate the current selection: ``year = 1996'' and
    ``United States.''}
}

%% Uncomment below to disable the manuscript note
%\renewcommand{\manuscriptnotetxt}{}

%% Copyright space is enabled by default as required by guidelines.
%% It is disabled by the 'review' option or via the following command:
% \nocopyrightspace

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%% START OF THE PAPER %%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

%% The ``\maketitle'' command must be the first command after the
%% ``\begin{document}'' command. It prepares and prints the title block.

%% the only exception to this rule is the \firstsection command
\firstsection{Introduction}

\maketitle

\begin{figure*}[b!]
  \centering
  \begin{tabular}{ccc}
  \begin{minipage}{2.5in}
    \centering
    \textbf{D3 (Javascript code)}
    \small
\begin{verbatim}
svg.selectAll("circle")
  .data(one_year)
  .enter().append("circle")
.attr("cx", function(d){
  return x_scale(d.fertility_rate);
}).attr("cy", function(d){
  return y_scale(d.life_expectancy);
}).attr("r", function(d){
  return size_scale(d.population);
}.style("fill", function(d){
  return color_scale(d.region);
})
\end{verbatim}
  \end{minipage}
  &
  \begin{minipage}{2.5in}
    \centering
    \textbf{Vega (JSON file)}
    \small
\begin{verbatim}
{ "marks": [{
  "type":"symbol",
  "from": {"data":"this_year"},
  "properties":{ "enter":{
    "x": {"field": "fertility_rate"},
    "y": {"field": "life_expectancy"},
    "size": {"field": "population"},
    "fill": {"field": "region"}
}}}]}
\end{verbatim}
  \end{minipage}
  &
  \begin{minipage}{2in}
    \centering
    \textbf{Animint (R code)}
    \small
\begin{verbatim}
geom_point(aes(
  x=fertility.rate,
  y=life.expectancy,
  color=region,
  size=population,
  clickSelects=country,
  showSelected=year),
  data=WorldBank)
\end{verbatim}
  \end{minipage}
  \end{tabular}
  \caption{Comparison of code used to define points on a scatterplot.
    Note that Animint is not as flexible as D3, but it results in
    shorter, more expressive code. Animint implements the
    \texttt{clickSelects} and \texttt{showSelected} aesthetics, 
    but D3 and Vega do not.}
  \label{fig:code}
\end{figure*}

Interactive, animated data visualization is a useful tool for
obtaining an intuitive understanding of patterns in multivariate data
sets. In this paper, we introduce Animint, a new domain-specific
language (DSL) for designing linked, interactive, animated data
visualizations. To explain exactly what kinds of visualizations we are
interested in creating, we begin with an example.

In this paper, we are concerned with data sets that can be described
as a data table, with columns for each variable and rows for each
observation or data point. Consider the World Bank data set, which
consist of several economic variables measured for 205 countries from
1960 to 2012. The visualization in Figure~1 shows six variables from
this data set: year, country, life expectancy, fertility rate, region,
and population. We have chosen to emphasize the country United States
and the year 1996. The benefit of the interactive visualization is
that the reader or user may interact with the plot to view data about
another country or time period.
%(\url{http://bit.ly/1fzfUdN}). 
Finally, since one of the variables in this visualization is the year
of measurement, it is natural to animate the visualization to see how
the data changes over time. The purpose of Animint is to make it easy
to design such interactive animations.

% I wanted to just emphasize the difference between an Animint
% interactive graphic and a static graphic. In static graphics the
% designer chooses both the aes mappings and the subset of data to
% show. However in Animint the designer only chooses the aes mappings
% and then the user is free to choose the selection. Do you have some
% idea how to get that message across?

In this paper we will discuss 3 important roles that contribute to the
creation of an Animint visualization: the developer, who implements
the Animint library; the designer, who uses the Animint library to
define a visualization; and the user, who views the visualization in a
web browser. The main goal of Animint is to provide an expressive
language for designers, while allowing users the freedom to interact
with the plot to selectively view data subsets of interest. The
designer specifies data sets and maps variables to interactive visual
elements using the Animint DSL, then uses the Animint library to
compile and save an interactive animation. The user writes no code,
but can view and interact with an Animint visualization by clicking
SVG elements in a web browser. A final goal is that the Animint
library developer should be the only role concerned with low-level
plotting details such as drawing axes and legends, freeing the
designer and user to focus on interpreting the data.
%interested in re-implementing the Animint
%system, we discuss details of its implementation in
%Section~\ref{sec:implementation}.

Our definition of an ``interactive'' visualization is synonymous to
what \citet{cleveland} called ``direct manipulation'' --- the user
directly specifies data of interest by using the mouse on the
corresponding plotted elements. Our definition of an ``animated''
visualization is one that shows new data points over time as the user
watches. The goal of the Animint DSL that we introduce in this paper
is to make it easy for designers to express visualizations which are
both animated and interactive.
%TODO: examples of animated and interactive, World
%Bank and Fig 9 of \citet{d3}.

The type of interactivity that we propose is closely related to the
system described by \citet{cleveland}. In that system, the user's
mouse creates a single rectangular brush which either defines the
selection (transient mode), or defines data points to add to or remove
from the selection (lasting mode or erasing mode). Cleveland also
defines several operations on the selection, such as labeling,
deleting, and enhanced linking. For example, in a scatter plot matrix,
Cleveland uses enhanced linking to highlight which points are selected
in each plot.

In Animint, the central concept of interactivity is a selection
variable, such as year or country in Figure~1. For each selection
variable, only 1 value can be selected at a time, e.g. year=1996 and
country=United States. Clicking a plot element changes the value of
the corresponding selection variable. Like Cleveland's system, Animint
supports enhanced linking to highlight the selected value of each
selection variable. In contrast to Cleveland's single rectangular
brush that select points in plots of a single data table, an Animint
designer may designate several selection variables in plots of several
linked data tables. To declare a clickable plot element that changes
the selected value of the year variable, an Animint designer writes
\texttt{clickSelects=year}.

To achieve data-driven animations, Animint defines one other important
operation involving selection variables: showing and hiding subsets of
data. For example, in the scatterplot of Figure~1 we draw a point for
each country, and want to move and change the size of each point as
the selected year changes. To accomplish this, an Animint designer can
simply declare \texttt{showSelected=year} which means to show only the
data with the selected value of year.

Using just these two keywords, a wide variety of interactive
visualizations can be defined. To make the selection automatically
change over time (animation), an Animint designer may declare one
variable as the \texttt{time} variable. Since it is perceptually
advantageous to have smooth transitions in data-driven animations
\citep{animated-transitions}, an Animint designer may also declare a
\texttt{duration} list of selection variables which should have smooth
transitions.

The Animint DSL is implemented as an extension of ggplot2
\citep{ggplot2-book, ggplot2-paper}, which is an R implementation of
the grammar of graphics \citep{wilkinson}. The ggplot2 language was
created as a high-level abstraction for non-interactive
visualizations. One of the key strengths of ggplot2 is that it allows
a designer to declare a visualization in terms of distinct geometric
elements, each with a clear aesthetic mapping from data variables to
geometric properties.  The Animint DSL extends ggplot2 by adding two
new aesthetics: \texttt{clickSelects} and \texttt{showSelected}.

The Animint library includes a compiler that converts a list of
ggplots to an interactive web visualization rendered using D3
\citep{d3}. One of the main reasons for the success and popularity of
D3 is that it allows visualizations to be specified using the
terminology of the Document Object Model (DOM), which makes learning
D3 easy for web designers. Animint's DSL abandons the DOM standard
and sacrifices some of the D3's flexibility to gain expressive
power. Thus, designers familiar with ggplot2 syntax are now able to
declare complex interactive animations in only a few dozen lines of
code using the Animint DSL. This enables R programmers to design a
large class of visualizations that were previously intractable to
implement.

Finally, another key strength of ggplot2 and D3 for visualization
design are the libraries' declarative syntax. \citet{declarative}
proposed a declarative syntax for animated transitions, and studied
the benefits of declarative languages for data visualization. Animint
is another declarative DSL, but defined at a higher level. It enables
designers to focus on data visualization, while the Animint library
developers can work on improving the lower-level rendering details.

The rest of this paper is organized as follows: we discuss related work in
Section~2, and the design of the Animint system in Section~3. Then we
perform a detailed comparison with other R packages in Section~4, and
show some example applications of Animint in Section~5. Finally, we
share some user feedback in Section~6 and then discuss future work in
Section~7.

%% \section{Introduction} %for journal use above \firstsection{..} instead

\section{Related Work}


In this section we offer a comparison between Animint and several
related systems, focusing on libraries/packages with free/open-source
software implementations in JavaScript/R. The main difference is that
Animint's declarative syntax allows interactive animations to be
expressed in fewer lines of code than the other packages.

\subsection{D3 and other JavaScript libraries}

The current implementation of Animint uses \href{http://d3js.org/}{D3}
to render interactive animations in a web browser \citep{d3}. D3 is
more powerful than animint, but is also more verbose. For example, the
code in Figure~\ref{fig:code} shows that it takes a lot more D3 code
than Animint code to define the scatterplot in the WorldBank
visualization. Animint's high-level DSL is also able to express
interactivity and animation in fewer lines of code than pure D3, but
there are some specialized D3 plots which can not be created using
Animint.

\begin{figure*}[b!]
  \centering
  \includegraphics[width=\textwidth]{figure-tornado}
  \caption{Interactive animation of tornadoes recorded from 1950 to
    2012 in the United States (\url{http://bit.ly/1hWvYo0}). \textbf{Left}:
    map of the lower 48 United States with tornado paths in 1982. The
    text shows the selected year, and clicking the map changes the
    selected state, currently Texas. \textbf{Right}: time series of
    tornado counts in Texas. Clicking a bar changes the selected year,
    and the text shows selected state and the number of tornadoes
    recorded there in that year (119 tornadoes in Texas in 1982).}
  \label{fig:tornado}
\end{figure*}


There are many other libraries which can generate web plots with
limited interactivity, but which are unable to produce interactive
animations. For example, the \texttt{rCharts} R package is a wrapper
around several JavaScript libraries \citep{rcharts}. The major
difference is that \texttt{rCharts} sacrifices some of the flexibility
of Animint for expressive power. Thus, \texttt{rCharts} can produce
several simple visualizations with only 1 line of R code, but it can
not produce interactive animations. In contrast, Animint's high-level
DSL can be used to specify more complex visualizations using only tens
of lines of R code.

\subsection{Animated graphics libraries}

One way to achieve animation in an iterative programming syntax is by
using a for statement to loop over the time variable. This is the main
idea of the \href{http://yihui.name/animation/}{animation} package
\citep{animation}. There are two main differences between this system
and Animint. First, the only interaction possible with
animation is rewinding and fast-forwarding through the
animation frames. Second, Animint uses an declarative DSL, which
enables more complex interactive animations to be defined in fewer
lines of code.

\subsection{Libraries based on the grammar of graphics}  

In this section we discuss the differences between Animint and
several other high-level DSLs for data visualization based on the grammar of graphics philosophy \citep{wilkinson}: ggplot2, Vega, and ggvis.

\begin{figure*}[b!]
  \centering
  \includegraphics[width=\textwidth]{figure-climate}
  \caption{Visualization containing 6 linked, interactive, animated
    plots of Central American climate data
    (\url{http://bit.ly/QcUrhn}). \textbf{Top}: for the selected time
    (December 1997), maps displaying the spatial distribution of two
    temperature variables, and a scatterplot of these two
    variables. The selected region is displayed with a black outline,
    and can be changed by clicking a rect on the map or a point on the
    scatterplot. \textbf{Bottom}: time series of the two temperature
    variables with the selected region shown in violet, and a
    scatterplot of all times for that region. The selected time can be
    changed by clicking a background tallrect on a time series or a
    point on the scatterplot. The selected region can be changed by
    clicking a line on a time series.}
  \label{fig:climate}
\end{figure*}

\paragraph{ggplot2}
The current implementation of Animint extends the declarative DSL of
\href{http://ggplot2.org/}{ggplot2} \citep{ggplot2-book,
  ggplot2-paper}. Strictly speaking, ggplot2 is for non-interactive
and non-animated visualizations. In this paper, we propose the
\texttt{clickSelects} and \texttt{showSelected} aesthetics for
ggplot2, which extend it to accommodate interactive, animated
graphics. This allows R users to create web-ready graphics using the
grammar of graphics, which is familiar to many statisticians and R
programmers.

\paragraph{Vega}
Like Animint, \href{http://trifacta.github.io/vega/}{Vega} is a
declarative DSL that builds on top of D3 \citep{vega}. Both sacrifice
some of the power of D3, while still allowing a wide variety of plots
to be defined in fewer lines of code than pure D3. The main idea of
Vega is to declaratively define a visualization using a special type
of JavaScript Object Notation (JSON) file. As discussed in
Section~\ref{sec:design}, Animint also internally uses a JSON file to
store meta-data about an interactive animation.

There are two main differences between Vega and Animint. First, the
Animint user writes R code, but the Vega user writes a JSON
file. Second and more importantly, Vega does not currently support the
complex data-driven interactive animations that Animint currently
supports. However, it should be possible for Vega to support
interactive animations in the future, by expanding their JSON
file format definition to support mark properties based on the
clickSelects and showSelected ideas introduced in this paper.
%in Section~\ref{sec:design}.


\paragraph{ggvis} The authors of ggplot2 are currently working on a
package for interactive graphics called
\href{http://ggvis.rstudio.com/}{ggvis} \citep{ggvis}. There are many
differences between ggvis and Animint, but the main difference is that
ggvis is more powerful and verbose, while Animint is more succinct for
expressing interactive plots that show/hide data subsets (for a
concrete example, see the comparison of World Bank data visualizations
in Table~\ref{tab:packages}). At the level of defining plots in R
code, a ggvis object corresponds to a single plot, while an Animint
object is a list of several plots which are linked using the
clickSelects and showSelected aesthetics. Another difference is that
sharing a ggvis visualization requires a web server that runs R and
shiny \citep{shiny}, but Animint uses static files and client-side
JavaScript so it does not require any special web server software. The
two packages also have different interactive features: ggvis uses
sliders, checkboxes, and other HTML form elements, and Animint
provides clickable SVG elements. This usually results in a richer
Animint data visualization using fewer lines of code. For example, in
a ggvis of the WorldBank data (Figure~1), it is natural to use a
slider to select the displayed year. In contrast, in Animint we used a
clickable multiple time series plot for the same purpose, giving the
viewer a more comprehensive view of these multidimensional data.

\subsection{Systems which are not publicly available}

The system described by \citet{cleveland} involves interaction via a
rectangular brush that can select several data points. Its enhanced
linking feature highlights the selected data points across several
plots, which is similar to the selection functionality implemented in
Animint. There are four important differences between Animint and this
system. First, Animint is based on a high-level DSL, but Cleveland's
system proposes no such language. Second, Animint supports a brush for
every selection variable, but Cleveland's system only supports a
single brush. Third, the current implementation of Animint only
supports selecting single values, but Cleveland's system supports
selecting several values. Importantly, this is a limitation of the
current implementation, not the proposed Animint DSL. Finally,
Animint is publicly available on GitHub
(\url{http://github.com/tdhock/animint}), but Cleveland's system is
not publicly available.

Another system with interactive facilities similar to Animint is
Tableau \citep{tableau}. Like Animint, it is based on a declarative
DSL. The Tableau DSL is called VizQL, which is based on another DSL
called Polaris \citep{polaris}. Unlike Animint, there is no
free/open-source software implementation of Tableau, so we will not
discuss it further.

\section{Design of the Animint system}
\label{sec:design}

In this section we explain the main idea of the Animint grammar for
interactive animations. We first explain the grammar using the World
Bank example of Figure~1, and then give implementation details of the
compiler and renderer.

\subsection{The Animint grammar for interactive animations}

<<opts, echo=FALSE, message=FALSE, cache=FALSE>>=
library(animint)
data(WorldBank)
write.csv(WorldBank, "WorldBank.csv")
opts_chunk$set(tidy=FALSE, eval=FALSE)
opts_knit$set(out.format="latex")
knit_theme$set("edit-matlab")
@ 

The main idea of Animint is that a large class of interactive plots
can be specified using just two interactive keywords:
\texttt{clickSelects} and \texttt{showSelected}. For example, after
clicking a \texttt{clickSelects=year} element, the plot
is updated to show only the \texttt{showSelected=year} elements
corresponding to the selected year.

Animint implements these two interactive keywords as aesthetics in
ggplot2. An aesthetic is a declarative mapping from data variables to
geometric plot elements. Some standard ggplot2 aesthetics are
\begin{description}
\item[x] horizontal position,
\item[y] vertical position,
\item[color] color outside (stroke in SVG),
\item[size] point or line thickness.
\end{description}
For example, consider the following R code which defines the points in the
World Bank data scatterplot on the right of Figure~1:

<<countryPoints>>=
countryPoints <- geom_point(
    aes(x=fertility.rate, y=life.expectancy, 
        color=region, size=population,
        clickSelects=country, 
        showSelected=year),
    data=WorldBank)
@

The code defines a \verb+geom_point+, which means to create a point
for every row in the \texttt{WorldBank} data table. The visual
characteristics of each point are defined by the values of the
corresponding data: the (x,y) position encodes fertility rate and life
expectancy, point color encodes the region, and point size encodes the
population. Note that scales are automatically constructed for the x
and y axes, and legends are automatically constructed for color and
size. The interactivity is also defined as a simple variable mapping:
\texttt{clickSelects=country} means that clicking a point changes the
selected country, and \texttt{showSelected=year} means to only plot
the points for the selected year.

In order to remind the plot user which subset of data are selected, we
will draw a text label with the selected year and country. First, we
create the year labels using

<<yearText-geom, tidy=FALSE>>=
yearText <- geom_text(
  aes(label=sprintf("year = ", year), 
      showSelected=year),
  x=5, y=80, 
  data=years)
@ 

Note that \texttt{data=years} specifies another data table, with 1 row
for each year. Animint does not require that linked plots originate
from the same data table; the \texttt{clickSelects} and
\texttt{showSelected} aesthetics will work as long as the different
data tables have common variable names (e.g. the \texttt{year}
variable is present in both \texttt{WorldBank} and \texttt{years}).
The \texttt{label} aesthetic is used to define the text from the year
variable, and only the selected year is shown due to the
\texttt{showSelected=year} aesthetic. Finally, note that since the
label \texttt{x} and \texttt{y} positions are constant, they are not
defined as aesthetics.

%% As the pairing of text geom with a corresponding \texttt{showSelected}
%% aesthetic is frequently useful in linked plots, animint also includes
%% a shorthand function to make defining this combination more efficient.

%% <<yearText-make>>=
%% yearText <- make_text(data=years, 
%%   x=5, y=80, showSelected="year")
%% @ 

We can also add another label to show the selected country:

<<countryText>>=
countryText <- geom_text(
    aes(x=fertility.rate, y=life.expectancy, 
        label=country,
        showSelected=country, 
        showSelected2=year),
    data=WorldBank)
@ 

Note that Animint allows any number of \texttt{showSelected}
aesthetics. In this example, \texttt{showSelected=country} combined
with \texttt{showSelected2=year} means to only show the subset of
labels corresponding to both the selected year and country.  Since
there is only 1 row for each (country,year) combination in the
WorldBank data, this has the effect of drawing the selected country's
label at the location of the selected year.

Having defined these 3 geometric elements, we combine them in a single
ggplot:

<<scatterPlot>>=
scatterPlot <- ggplot()+
  countryPoints+
  yearText+
  countryText
@ 

This completes the definition of the scatterplot. Now, we discuss the
time series on the left of Figure~1. First, the tallrects in the
background are used to select the year:

<<yearRects-geom>>=
yearRects <- geom_tallrect(
  aes(xmin=year-1/2, xmax=year+1/2, 
      clickSelects=year),
  data=years, alpha=1/2)
@ 

%Animint is designed for
%interactivity via direct manipulation of the plot elements. 
%To facilitate this goal, 
The tallrect is an Animint extension useful for selecting the variable
which is plotted on the x axis, such as \texttt{year} in this
example. The tallrect plots a rectangle for every row of the
\texttt{years} data table. The rectangle spans the entire y region,
and the \texttt{xmin} and \texttt{xmax} aesthetics define the left and
right limits. Since the designer specified \texttt{clickSelects=year},
users can click on a tallrect to select a year. Finally,
\texttt{alpha=1/2} specifies that the selected tallrect should have an
opacity of 50\%. Since color is black by default, this results in a
selected semi-transparent tallrect which appears grey. Since
non-selected \texttt{clickSelects} plot elements have 1/2 less
opacity by default, this results in non-selected rectangles which
are completely transparent, blending in with the white
background.


%% Animint also provides a shorthand syntax for tallrects, as they are a
%% common geom/aesthetic pairing in linked plots.

%% <<yearRects-make>>=
%% yearRects <- make_tallrect(WorldBank, "year")
%% @ 

%% This approach allows us to utilize both plots to display meaningful
%% information: we can overlay the tallrects in the first plot with time
%% series data while still using the tallrects to modify the second
%% plot. Similar linked graphs could be produced with D3, but the grammar
%% of graphics approach allows for fewer lines of code and simpler
%% debugging.

To create the time series plot, we combine the tallrects above with
lines. To declare that clicking a line should change the selected
country, we use the \texttt{clickSelects=country} aesthetic:

<<timeSeries, tidy=FALSE>>=
timeSeries <- ggplot()+
  yearRects+
  geom_line(
    aes(x=year, y=life.expectancy, 
        group=country, color=region,
        clickSelects=country),
    data=WorldBank, size=3, alpha=3/5)
@ 

Note that both the \texttt{timeSeries} and \texttt{scatterPlot}
objects are valid ggplots. However, plotting them using the standard
ggplot2 library will show a non-interactive plot will all
geometric elements, including data for all years and countries. To
plot them with Animint, we define a list of ggplots and options, then
call the \texttt{gg2animint} compiler:

<<gg2animint,fig.pos='htbp'>>=
viz <- 
  list(scatterPlot=scatterPlot,
       timeSeries=timeSeries,
       time=list(variable="year", ms=3000),
       duration=list(year=1000))
gg2animint(viz, out.dir="WorldBank")
@ 

The \texttt{time} option specifies that in absence of user
interaction, we want the plots to animate over time, progressing at a
rate of one year every 3 seconds. We also use the \texttt{duration}
option to specify a smooth transition over 1 second for the year
variable. The \texttt{gg2animint} compiler saves some data files and a
web page with the interactive plot, and opens it in a web
browser. 

\subsection{Implementation details}
\label{sec:implementation}

As shown in Figure~\ref{fig:design}, the Animint system is implemented
in 2 parts: the compiler and the renderer.

\begin{figure}[b!]
  \centering
  \includegraphics[width=\columnwidth]{figure-design}
  \caption{Schematic explanation of compilation and rendering the
    World Bank visualization shown in Figure~1. \textbf{Top}: the
    interactive animation is a list of 4 R objects: 2 ggplots and 2
    option lists. \textbf{Center}: Animint R code compiles data in
    ggplot geoms to a database of comma-separated values (CSV) files
    (\textcolor{red}{$\rightarrowtriangle$}). It also compiles plot
    meta-data including ggplot variable mappings, animation time
    options, and transition duration options to a JSON meta-data file
    ($\rightarrowtriangle$). \textbf{Bottom}: those data-dependent
    compiled files are combined with data-independent JavaScript and
    HTML files which render the interactive animation in a web browser
    (\textcolor{blue}{$\rightarrowtriangle$}).}
  \label{fig:design}
\end{figure}

The compiler is implemented in about 1000 lines of R code that
converts a list of ggplots and options to a comma-separated values
(CSV) file database and a JSON plot meta-data file. The compiler scans
the aesthetics in all of the ggplots to determine how many selection
variables are present, and which plots to update after a selection
variable is clicked. It also uses ggplot2 to automatically calculate
the axes scales, legends, and labels. It outputs this information to
the JSON plot meta-data file. It also uses ggplot2 to convert data
variables (e.g. life expectancy and region) to visual properties
(e.g. y position and color), saving this information in the CSV file
database. It also copies the rendering engine (\texttt{index.html},
\texttt{d3.v3.js}, and \texttt{animint.js} files) to the plot
directory. Since the compiled plot is just a directory of files, the
designer can easily upload interactive plots to the web for sharing
visualizations with users.

The \texttt{animint.js} renderer is implemented in about 1000 lines of
JavaScript/D3 code that renders the CSV and JSON plot data files as
SVG in a web browser. The main idea for implementing interactivity is
that clicking a \texttt{clickSelects=year} geom calls the
\verb|update_selector| function, which stores the newly selected value
of year, then calls \verb|update_geom| to redraw every geom with
\texttt{clickSelects=year} or \texttt{showSelected=year}. Importantly,
animation is achieved by using the JavaScript \texttt{setInterval}
function, which executes \verb|update_selector| with a new value, every
few seconds.
  
\section{Results and comparison study on World Bank data}
\label{sec:compare}

To show the advantages that the Animint grammar brings for creating
interactive and animated data visualizations, we implemented the World
Bank visualization of Figure~1 using two other R packages
(Table~\ref{tab:packages}). The main result of our comparison is that
Animint requires significantly fewer lines of code, since it uses a
declarative grammar to specify interactive animations.

%\subsection{D3} TODO: discuss D3.


\subsection{R package animation}
\label{sec:compare-animation}

We designed a version of the WorldBank visualization with limited
interactivity, using 38 lines of R code and the \texttt{animation}
package (\url{http://bit.ly/1hnUnkE}). The main idea behind this
approach is to use an imperative programming style with for loops to
create a static PNG image for each year of the data, and then show
these images in sequence. The main drawback to this approach is that
the resulting plot is only interactive with respect to the year
variable. In other words, the designer must select a country to
emphasize, and the user does not have that choice. Another drawback is
that R package \texttt{animation} does not support smooth transitions
between animation frames. In contrast, using only 20 lines of the
Animint DSL, the Animint package achieves smooth transitions and
interaction with respect to both year and country variables.

\begin{table}[t!]
%% Table captions on top in journal version
  \caption{Implementation complexity and features 
    of the World Bank data visualization
    %of Figure~1 
    using several libraries that can create interactive animations.
    For each library
    we show the number of lines of code (LOC), programming style, 
    number of interaction variables, and URL of the interactive version. 
%  Note that different countries can not be interactively selected using
% the visualization created with R package animation.
  }
 \label{tab:packages}
 \scriptsize
 \begin{center}
  \begin{tabular}{cccccc}
    library & 
    LOC &
    style &
    %language &
    %years & 
    interaction vars &
    http://bit.ly/
    \\
    \hline
    animint & 
    20 &
    declarative & 
    %R &
    %2013- & 
    several & 
      \bitly{1fzfUdN}
    \\
    animation & 
    38 &
    imperative &
    %R  &
    %2007- & 
    1 = time & 
    \bitly{1hnUnkE}
    \\
    %% D3 & 
    %% TODO &
    %% JavaScript & 
    %% %2011- & 
    %% several & 
    %% %declarative & 
    %% \\
    ggvis/shiny & 
    84 &
    reactive & 
    %R  &
    %2012- & 
    several & 
    \bitly{1diUYsg}
    \\
  \end{tabular}
 \end{center}
\end{table}

\subsection{Client-server systems like ggvis/shiny}

We designed another version of the World Bank data visualization in 84
lines of R code, using the ggvis graphics library combined with the
recommended shiny web server package \citep{shiny, ggvis}
(\url{http://bit.ly/1diUYsg}). Showing and hiding data subsets was
accomplished by clicking on a slider for year and a menu for country,
not by clicking on the plot elements. In contrast, we designed Figure~1
using only 20 lines of R code with the Animint package. The reason why
the implementation is significantly simpler using Animint is because
its DSL is designed specifically for this type of interactive
animation.
%Although creating such visualizations in ggvis+shiny is
%possible, it requires significantly more work for limited
%interactivity.

Another difference is the amount of work required to deploy or share a
visualization. A compiled Animint visualization consists of static
CSV, JSON, HTML, and JavaScript files which can be easily served with
any web server. In contrast, ggvis+shiny requires a web server with R
installed, significantly complicating deployment to the web.

There are also inherent speed tradeoffs to using a client-server
plotting system like ggvis+shiny rather than an entirely web
client/JavaScript-based system like Animint. There is one main
difference between these two types of systems that affects
responsiveness of a web-based interactive plotting system:
client-server communication overhead. All the \mbox{Animint}
JavaScript plot rendering code is executed in the web browser, whereas
ggvis executes some plotting code on the server. This means that after
a mouse click, ggvis can not update a plot immediately, but instead
must wait for the server to respond with the plot data.

We quantified speed differences between the two systems by timing web
page loading using DevTools in the Chromium web browser Version
33.0.1750.152 Ubuntu 12.04 (256984). We also used \texttt{getTime()}
in JavaScript to record timings for interactive plot updates (on a
desktop computer with a 2.8GHz Intel Core i7 CPU). Using ggvis with a
local web server and the World Bank data resulted in a web page that
loaded quickly (about 1.4s), but updated the plot with a noticeable
lag after each mouse click (500--1000ms). Note that since we used a
local web server, these times represent the overhead of the web server
system, and would be larger with a remote web server.

When we used Animint to make the World Bank data visualization, the
compilation from R objects to 2.3MB of uncompressed CSV data files
took 2.5s. Using a local web server, the Animint JavaScript rendered
the plot very quickly (100--200ms). We also observed very fast plot
updates after mouse clicks in Animint: 20--30ms response times for
selecting the year, and 60--70ms response times for selecting the
country. 
%Furthermore, in web server systems the client may not cache
%previously viewed subsets, which results in calculations inefficiently
%being performed several times rather than simply saved for quick
%viewing later. 

The conclusion of our speed comparison is that the overhead of
communicating with a web server results in significant slowdowns for
interactive animations. It is clear that for quick response times, it
is preferable to use an entirely JavaScript-based system like
Animint.

In contrast, a web server system like ggvis+shiny would be more
appropriate for interactive animations that have many more subsets of
the data than can ever be transferred over the network. In that case,
the web server will initially send only the first data subset, and
then send only the subsets of data that the client requests. However,
since the data sets we examined were not too large
(Table~\ref{tab:examples}), client-side rendering using Animint
resulted in quick, responsive interactive animations.

Another application for which a web server system like ggvis+shiny
would be preferable is for performing arbitrary calculations in R/C
code on the server and then sending the result across the
network. However, this power is not really necessary for interactive
animations, since the only operation needed is calculating data
subsets.

\section{Example applications}

In this section we discuss the range of examples that we have designed
with Animint. Table~\ref{tab:examples} shows several characteristics
of nine different interactive visualizations that we have designed
using Animint.

\begin{table*}[b!]
  \centering
  \input{table-examples}
  \caption{Characteristics of nine interactive visualizations designed with 
    Animint. From left to right, we show the data set name, the 
    lines of R code including data processing but not including comments
    (80 characters max per line), 
    the amount of time it takes to compile the visualization (seconds), 
    the total size of the uncompressed CSV files in megabytes (MB),
    the total number of data points (rows), 
    the median number of data points shown at once (onscreen),
    the number of data columns visualized (variables), 
    the number of clickSelects/showSelected variables (interactive),
    the number of linked panels (plots),
    if the plot is animated, 
    and the corresponding Figure number in this paper (Fig).
  }
\label{tab:examples}
\end{table*}

\subsection{Animated examples}

Mostly useful when one of the variables is time, as in Figure~1. TODO
COMMENTARY.

Figure~\ref{fig:tornado} shows an interactive animation of the tornado
data. TODO COMMENTARY.


Figure~\ref{fig:climate} shows an interactive animation of the climate
data. TODO COMMENTARY.


\subsection{Non-animated examples}

When the data to visualize do not contain a time variable, we have
found that Animint is still useful for creating interactive but
non-animated plots.

TODO more discussion -- Discuss relationships between multivariate data. I may be able to provide an example in soybeans (but I'm not sure if I'm allowed to share that data, so it might be good to find some other linked variables - the ones I'm thinking about are protein, oil, and yield.)

\section{User feedback and observations}

We and our users have created interactive visualizations using Animint
that would be too complex to implement in other systems. 
%% Examples
%% discussed in previous sections include animated visualizations of
%% multiple time series data and non-animated visualizations of other
%% high-dimensional data sets. 
In this section we share comments and
constructive criticism that we have obtained from our users.

R users have found that Animint is easy to learn. One statistics
Ph.D. student writes, ``animint is a fantastic framework for creating
interactive graphics for someone familiar with R and ggplot2's grammar
of graphics implementation. The API is very intuitive and allows one
to quickly bring their static graphics to life in a way that
facilitates exploratory data analysis.''

For the \texttt{prior} data visualization
(\url{http://bit.ly/1peIT7t}), the Animint user is a machine learning
researcher who developed an algorithm and applied it to 4 benchmark
data sets. He wanted to explore how his algorithm performed, in
comparison to a baseline learning algorithm. He appreciated the
intuition about his algorithm's performance that he learned from the
interactive plots: ``Interactive plotting allows us to explore all
relationships of our high-dimensional dataset and gives us an
intuitive understanding of the performance of our proposed
algorithm. An intuitive understanding of the results is important
since it shows under which conditions our proposed method works well
and provides avenues for further research.''


Another user from a machine learning background found the interactive
plots useful for presenting his work: ``the `regularization path' is a
difficult concept to demonstrate in my research. The [Animint
\url{http://bit.ly/1gVb8To}] helped greatly by rendering an
interactive plot of regularization path, likelihood, and graph at the
same time and illustrating their connections. It also reveals an
interesting phenomenon that maximizing the testing likelihood actually
gives many false positives.''

In another application, the Animint user was a genomics researcher:
``viewing and exploring my complex intestinal microbiome dataset in
[Animint] allowed me to grasp the patterns and relationships between
samples at an almost intuitive level. The interactive aspect of it was
very helpful for browsing through the dataset --- especially when
compared to scrolling through huge spreadsheets! Constructive
criticism: finding ways to speed up data loading would help maximize
the software's utility for the visualization of large datasets.''

Finally, users also appreciated the web-based output format, and the
detail that is possible to show in interactive plots, but impossible
to show in publications: ``...  the web interface is simple and easy
to use.  It also enables us to publish more detailed interactive
results on our website to accompany the results presented in
publications.''

\section{Limitations and future work}

There are several limitations to the current implementation of
Animint, which suggest avenues for future work.

As discussed in Section~\ref{sec:design} and illustrated in
Figure~\ref{fig:design}, the compiler is written in R, and the
renderer is written in JavaScript. This means that Animint developers
must be proficient in both R and JavaScript. This represents a
significant barrier for source code contributions from developers who
are proficient with one language but not the other.

Animint users define interactive animations using only R code, and no
knowledge of JavaScript is necessary. This is convenient for useRs
from a statistical background, but presents a barrier for web
developers who are more familiar with JavaScript than R. For these web
developers, it would be advantageous in the future to implement a
compiler and renderer in pure JavaScript, by
possibly building clickSelects and showSelected extensions into Vega
\citep{vega}.

The current Animint implementation is limited to two specific types of
interactivity: highlighting the selected \texttt{clickSelects}
element, and showing/hiding \texttt{showSelected} elements. In the
future, we could implement several types of interactivity without
changing the Animint DSL. Examples include zooming, multiple
selection, increase/decrease animation speed, and plot
resizing. However, some kinds of interactivity would require additions
to the Animint grammer. For example, a \texttt{tooltip} aesthetic
could be used to indicate the text the user views when they hover the
mouse over a data point.

Animint's performance can be measured using speed, memory, and disk
space requirements in the compilation and rendering steps. In general,
the performance of the compilation step is related to the total amount
of data (``rows'' column in Table~\ref{tab:examples}), and the
performance of the rendering step is related to the amount of data
displayed at once (``onscreen'' column in
Table~\ref{tab:examples}). Although we showed in
Section~\ref{sec:compare} that Animint provides smoother interactivity
than client-server systems, future versions of Animint could
definitely be made even more efficient and responsive. For example,
the compilation step currently saves geom-specific CSV files and could
be improved by saving CSV files for each showSelected subset of
data. This would also allow for faster rendering for large data sets,
since then the plots could be displayed as soon as the first selection
is downloaded. In contrast, the current code downloads all of the data
before displaying the geom.

This highlights one of the main motivations for using a declarative
DSL like Animint: none of the designer's R code needs to be changed to
implement improvements like this. Instead, the Animint developers just
need to work on a better compiler and rendering engine. Indeed,
\citet{declarative} noted that this is one of the main benefits of
declarative language design: ``By decoupling specification from
implementation, developers can implement language optimizations
without interfering with the work of designers.'' While several
optimizations remain to be implemented, the current Animint library
already provides an efficient syntax for the design of interactive,
animated data visualizations.

\acknowledgments{The authors wish to thank Animint users Carson
  Sievert, MC Du Plessis, Song Liu, and Nikoleta Juretic who have
  contributed constructive criticism and helped its development.  }

% TDH 13 March 2014 This was in the template.tex file.
%\bibliographystyle{abbrv}

\bibliographystyle{abbrvnat}

%%use following if all content of bibtex file should be shown
%\nocite{*}
\bibliography{refs}
\end{document}
